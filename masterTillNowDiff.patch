diff --git a/deactivated rebar.config.script b/deactivated rebar.config.script
new file mode 100644
index 0000000..68cc967
--- /dev/null
+++ b/deactivated rebar.config.script	
@@ -0,0 +1,26 @@
+%% -*- mode:erlang; erlang-indent-level: 4; indent-tabs-mode: nil -*-
+
+case os:getenv("AE_ROOT") of
+    false ->
+        CONFIG;
+    Root ->
+        MyDeps = proplists:get_value(deps, CONFIG, []),
+        AeDeps = proplists:get_value(
+                   deps,
+                   rebar_config:consult(Root)),
+        MyDeps1 =
+            lists:map(
+              fun(A) when is_atom(A) ->
+                      case lists:keyfind(A, 1, AeDeps) of
+                          false -> A;
+                          Dep -> Dep
+                      end;
+                 (Dep) ->
+                      Dep
+              end, MyDeps),
+        case MyDeps1 of
+            [] -> CONFIG;
+            _ when MyDeps1 =/= MyDeps ->
+                lists:keystore(deps, 1, CONFIG, {deps, MyDeps1})
+        end
+end.
diff --git a/rebar.config b/rebar.config
index d59b72e..240a9d3 100644
--- a/rebar.config
+++ b/rebar.config
@@ -11,5 +11,7 @@
         lager,
         cowboy,
         aeserialization,
-        jsx
-       ]}.
+        jsx,
+        {ebip39,           
+                {git, "https://github.com/aeternity/ebip39.git"}}
+       ]}.
\ No newline at end of file
diff --git a/rebar.lock b/rebar.lock
index 37176fc..4bcb09d 100644
--- a/rebar.lock
+++ b/rebar.lock
@@ -15,10 +15,18 @@
   {git,"https://github.com/ninenines/cowlib",
        {ref,"3ef5b48a028bb66f82b452c98ae515903096641c"}},
   1},
+ {<<"ebip39">>,
+  {git,"https://github.com/aeternity/ebip39.git",
+       {ref,"75203401b39aeba45f20b7128f84eeda6a2a4ab6"}},
+  0},
  {<<"enacl">>,
   {git,"https://github.com/aeternity/enacl.git",
        {ref,"26180f42c0b3a450905d2efd8bc7fd5fd9cece75"}},
   1},
+ {<<"epbkdf2">>,
+  {git,"https://github.com/aeternity/epbkdf2",
+       {ref,"38a2c730fdbe250f0adf198ea4bd24352dd5b223"}},
+  1},
  {<<"goldrush">>,{pkg,<<"goldrush">>,<<"0.1.9">>},1},
  {<<"jsx">>,
   {git,"https://github.com/talentdeficit/jsx.git",
diff --git a/src/aeplugin_dev_mode.app.src b/src/aeplugin_dev_mode.app.src
index 872ae7b..dfb00f4 100644
--- a/src/aeplugin_dev_mode.app.src
+++ b/src/aeplugin_dev_mode.app.src
@@ -5,7 +5,7 @@
   {registered, []},
   {mod, {aeplugin_dev_mode_app, []}},
   {start_phases, [{check_config, []}]},
-  {applications, [kernel, stdlib, aecore]},
+  {applications, [kernel, stdlib, aecore, ebip39]},
   {env,
    [{'$setup_hooks',
      [{normal,
diff --git a/src/aeplugin_dev_mode_acc_gen.erl b/src/aeplugin_dev_mode_acc_gen.erl
new file mode 100644
index 0000000..73907ef
--- /dev/null
+++ b/src/aeplugin_dev_mode_acc_gen.erl
@@ -0,0 +1,50 @@
+-module(aeplugin_dev_mode_acc_gen).
+-export([generate_from_mnemonic/3, generate_accounts/2, generate_accounts/0]).
+
+generate_from_mnemonic(Mnemonic, Quantity, Balance) ->
+    Seed = ebip39:mnemonic_to_seed(Mnemonic, <<"">>),
+    Derived = derive_from_seed(Seed, Quantity),
+    to_all_formats(Derived, Balance).
+
+generate_accounts() ->
+    generate_accounts(2, 10000000000000000000000000000000).
+    
+    generate_accounts(Quantity, Balance) ->
+    Mnemonic = ebip39:generate_mnemonic(128),
+    % io:fwrite("------> Mnemonic: ~p ~n", [Mnemonic]),
+    generate_from_mnemonic(Mnemonic, Quantity, Balance).
+
+derive_from_seed(Seed, Quantity) ->
+    [ eaex10:derive_aex10_from_seed(Seed, 0, Index) || Index <- lists:seq(1, Quantity)].
+
+%% the node, the devmode internals and the devmode's public data need different formats of the account data. combining at least the latter 2 might be worked on next.
+to_all_formats(ListOfDerivedKeys, Balance) ->
+    ReadableFormat = lists:map(fun(D) -> 
+        #{pub_key := Public, priv_key := Private} = eaex10:private_to_public(D),    
+        #{pub_key => binary_to_atom(aeser_api_encoder:encode(account_pubkey, Public)),
+             priv_key => binary_to_atom(hexlify(<<Private/binary, Public/binary>>)), 
+             balance => Balance } 
+            end,
+        ListOfDerivedKeys),
+
+    DevmodeFormat = lists:map(fun(D) -> 
+        #{pub_key := Public, priv_key := Private} = eaex10:private_to_public(D),    
+        {Public, <<Private/binary, Public/binary>>} 
+            end,
+        ListOfDerivedKeys),
+
+    NodeFormat = lists:map(fun(D) -> 
+        #{pub_key := Public} = eaex10:private_to_public(D),    
+        {binary_to_atom(aeser_api_encoder:encode(account_pubkey, Public)), Balance} 
+            end,
+        ListOfDerivedKeys),
+
+    #{readableFormat => ReadableFormat, 
+        devmodeFormat => DevmodeFormat, 
+        nodeFormat => NodeFormat}.
+
+hexlify(Bin) when is_binary(Bin) ->
+    << <<(hex(H)),(hex(L))>> || <<H:4,L:4>> <= Bin >>.
+
+hex(C) when C < 10 -> $0 + C;
+hex(C) -> $a + C - 10.
diff --git a/src/aeplugin_dev_mode_app.erl b/src/aeplugin_dev_mode_app.erl
index a1b411c..9cc4692 100644
--- a/src/aeplugin_dev_mode_app.erl
+++ b/src/aeplugin_dev_mode_app.erl
@@ -14,8 +14,15 @@
 -define(OS_ENV_PFX, "DEVMODE").
 
 start(_Type, _Args) ->
+    Workspace = determine_workspace(),
+    lager:info("<<<<----------Devmode: Test In ! ~p ~n", [here]),
+    maybe_generate_accounts(Workspace),
     {ok, Pid} = aeplugin_dev_mode_sup:start_link(),
     ok = start_http_api(),
+    %%io:fwrite("Accounts read from disk: ~p ~n", [read_preset(accounts, 1)]),
+    %%io:fwrite("Accountsgenerated: ~p ~n", [aeplugin_dev_mode_accs:generate_accounts(5, 10000)]),
+    % io:fwrite("Accountsgenerated: ~p ~n", [ebip39:generate_mnemonic(128)]),
+    %%io:fwrite("All accounts in chain: ~p ~n", [aec_chain:all_accounts_balances_at_hash(aec_chain:genesis_hash())]),
     {ok, Pid}.
 
 start_phase(check_config, _Type, _Args) ->
@@ -30,6 +37,64 @@ stop(_State) ->
     stop_http_api(),
     ok.
 
+maybe_generate_accounts(Workspace) ->
+    %% A CLI tool will provide a DB path representing either a work space, or some existing database (maybe for the sake of using some synced node data)
+    %% So here we check whether that DB path already has any data present. if not, it's a new workspace and we generate accounts. the node later looks 
+    %% for that file when in devmode and, if present uses it instead of its hardcoded accounts json.
+    lager:info("---------->>> In ! ~p ~n", [here]),
+    case os:getenv("AE__CHAIN__DB_PATH") of
+        false -> ok;
+        Path -> 
+            case is_empty_dir(Path) of 
+                true ->
+                    lager:info("---------->>> Found empty workspace, generating Accounts ! ~p ~n", []),
+                    %% TODO: Add further account creation options here, for now use default acc generating
+                    AccountsList = try aeu_acc_generator:generate_accounts() of
+                                #{nodeFormat := Accs} when is_list(Accs) -> Accs
+                            catch
+                                error:_ -> 
+                                    erlang:error(failed_generating_devmode_accs)
+                            end,
+                    
+                    AccountsJSON = 
+                            try jsx:encode(AccountsList) of
+                                List when is_list(List) -> List
+                            catch
+                                error:_ ->
+                                    erlang:error(failed_jsonencoding_generated_devmode_accounts)
+                            end,
+                    JSONfilePath = filename:join(Path, "devmode_accs_" ++ Workspace ++ ".json"),
+                    {ok, File} = file:open(JSONfilePath, [write]),
+                    lager:info("---------->>> Writing accounts file to: ~p ~n", [JSONfilePath]),
+                    file:write(File, AccountsJSON);
+                false -> ok
+            end
+    end.
+
+determine_workspace() ->
+    %% TODO: Determine some work space name for existing databases, too
+    case os:getenv("AE__CHAIN__DB_PATH") of
+        false -> <<"Existing Database">>;
+        Path -> lists:last(filename:split(os:getenv(Path)))
+    end.
+
+
+is_empty_dir(Dir) ->
+    case file:list_dir_all(Dir) of
+        {ok, []} -> true;
+        _ -> false
+    end.
+         
+
+% % don't commit, this was just for debugging
+% read_preset(accounts, Release) ->
+%     PresetAccountsFile = aec_fork_block_settings:accounts_file_name(Release),
+%     case file:read_file(PresetAccountsFile) of
+%         {ok, _} = OK ->     io:fwrite("read_preset accounts for release: ~p ~p ~n", [Release, OK]), OK;
+%         {error, Err} -> {error, {Err, PresetAccountsFile}}
+%     end.
+
+
 check_env() ->
     case aeu_plugins:is_dev_mode() of
         true ->
@@ -48,6 +113,7 @@ start_http_api() ->
     {ok, _} = cowboy:start_clear(devmode_listener,
                                  [{port, Port}],
                                  #{env => #{dispatch => Dispatch}}),
+    lager:info("Starting devmode API on port ~p", [Port]),
     ok.
 
 stop_http_api() ->
